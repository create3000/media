<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 4.0//EN" "https://www.web3d.org/specifications/x3d-4.0.dtd">
<X3D profile='Interchange' version='4.0' xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-4.0.xsd'>
  <head>
    <component name='EnvironmentalSensor' level='3'/>
    <component name='EventUtilities' level='1'/>
    <component name='Geometry2D' level='2'/>
    <component name='Layering' level='1'/>
    <component name='PointingDeviceSensor' level='1'/>
    <component name='Scripting' level='1'/>
    <component name='Sound' level='3'/>
    <component name='Text' level='1'/>
    <component name='X_ITE' level='1'/>
    <unit category='angle' name='degree' conversionFactor='0.017453292519943295'/>
    <meta name='comment' content='Rise and Shine'/>
    <meta name='created' content='Wed, 27 Sep 2017 11:50:59 GMT'/>
    <meta name='creator' content='Holger Seelig'/>
    <meta name='generator' content='Sunrize X3D Editor V1.10.4, https://create3000.github.io/sunrize/'/>
    <meta name='generator' content='x3d-tidy V2.2.4, https://www.npmjs.com/package/x3d-tidy'/>
    <meta name='modified' content='Sat, 27 Sep 2025 22:18:04 GMT'/>
  </head>
  <Scene>
    <ExternProtoDeclare name='MFInt32' url='"MFInt32.x3d#MFInt32"'>
      <field accessType='inputOnly' type='SFTime' name='set_triggerTime'/>
      <field accessType='inputOutput' type='MFInt32' name='keyValue'/>
      <field accessType='outputOnly' type='MFInt32' name='value_changed'/>
    </ExternProtoDeclare>
    <ProtoDeclare name='Maze'>
      <ProtoInterface>
        <field accessType='inputOnly' type='SFTime' name='set_triggerTime'/>
        <field accessType='inputOutput' type='SFInt32' name='width' value='11'/>
        <field accessType='inputOutput' type='SFInt32' name='height' value='11'/>
        <field accessType='inputOutput' type='SFFloat' name='complexity' value='0.75'/>
        <field accessType='inputOutput' type='SFFloat' name='density' value='0.75'/>
        <field accessType='outputOnly' type='MFInt32' name='matrix'/>
        <field accessType='outputOnly' type='SFTime' name='generatedTime'/>
      </ProtoInterface>
      <ProtoBody>
        <Script DEF='MazeScript'
            directOutput='true'>
          <field accessType='inputOnly' type='SFTime' name='set_triggerTime'/>
          <field accessType='inputOutput' type='SFInt32' name='width'/>
          <field accessType='inputOutput' type='SFInt32' name='height'/>
          <field accessType='inputOutput' type='SFFloat' name='complexity'/>
          <field accessType='inputOutput' type='SFFloat' name='density'/>
          <field accessType='inputOutput' type='MFInt32' name='matrix'/>
          <field accessType='outputOnly' type='SFTime' name='generatedTime'/>
          <IS>
            <connect nodeField='set_triggerTime' protoField='set_triggerTime'/>
            <connect nodeField='width' protoField='width'/>
            <connect nodeField='height' protoField='height'/>
            <connect nodeField='complexity' protoField='complexity'/>
            <connect nodeField='density' protoField='density'/>
            <connect nodeField='matrix' protoField='matrix'/>
            <connect nodeField='generatedTime' protoField='generatedTime'/>
          </IS>
<![CDATA[ecmascript:

function set_triggerTime (value, time)
{
	generateMaze (complexity, density);

	generatedTime = time;
}

function generateMaze (complexity, density)
{
   // Only odd shapes

	if (width  % 2 == 0) ++ width;
	if (height % 2 == 0) ++ height;

	// Adjust complexity and density relative to maze size

	complexity = Math .floor (complexity * 5 * (width + height));
	density    = Math .floor (density * Math .floor (width / 2) * Math .floor (height / 2));

	// Build actual maze

	matrix .length = width * height;

	for (var i = 0; i < matrix .length; ++ i)
		matrix [i] = 0;

	// Fill borders

	for (var x = 0; x < width; ++ x)
	{
		matrix [getIndex (x, 0)]          = 1;
		matrix [getIndex (x, height - 1)] = 1;
	}

	for (var y = 0; y < height; ++ y)
	{
		matrix [getIndex (0, y)]         = 1;
		matrix [getIndex (width - 1, y)] = 1;
	}

	// Make aisles

	for (var i = 0; i < density; ++ i)
	{
		var
			x = Math .round (random (0, Math .floor (width  / 2))) * 2,
			y = Math .round (random (0, Math .floor (height / 2))) * 2;

		matrix [getIndex (x, y)] = 1;

		for (var j = 0; j < complexity; ++ j)
		{
			var neighbours = [ ];

			if (x > 1)          neighbours .push ([x - 2, y]);
			if (x < width - 2)  neighbours .push ([x + 2, y]);
			if (y > 1)          neighbours .push ([x, y - 2]);
			if (y < height - 2) neighbours .push ([x, y + 2]);

			if (neighbours .length)
			{
				var neighbour = neighbours [Math .round (random (0, neighbours .length - 1))];

				var
					x_ = neighbour [0],
					y_ = neighbour [1];

				if (matrix [getIndex (x_, y_)] == 0)
				{
					matrix [getIndex (x_, y_)] = 1;
					matrix [getIndex (x_ + Math .floor ((x - x_) / 2), y_ + Math .floor ((y - y_) / 2))] = 1;

					x = x_;
					y = y_;
				}
			}
		}
	}
}

function getIndex (x, y)
{
	return width * y + x;
}

function random (min, max)
{
	return Math .random () * (max - min) + min;
}
]]>
        </Script>
      </ProtoBody>
    </ProtoDeclare>
    <ProtoDeclare name='MazeGeometry'>
      <ProtoInterface>
        <field accessType='inputOutput' type='MFInt32' name='type' value='1'/>
        <field accessType='inputOutput' type='SFBool' name='rotate' value='true'/>
        <field accessType='inputOutput' type='SFVec3f' name='mazeElementSize' value='2 2 2'/>
        <field accessType='inputOutput' type='MFString' name='mazeElementUrl'/>
        <field accessType='inputOutput' type='SFNode' name='maze'/>
      </ProtoInterface>
      <ProtoBody>
        <Collision>
          <InstancedShape DEF='Proxy' containerField='proxy'/>
          <InstancedShape DEF='Shape'/>
        </Collision>
        <Inline DEF='_1'
            global='true'>
          <IS>
            <connect nodeField='url' protoField='mazeElementUrl'/>
          </IS>
        </Inline>
        <LoadSensor DEF='_2'>
          <Inline USE='_1'/>
        </LoadSensor>
        <Script DEF='MazeGeometryScript'
            directOutput='true'>
          <field accessType='inputOnly' type='SFTime' name='set_loadTime'/>
          <field accessType='inputOnly' type='SFTime' name='set_triggerTime'/>
          <field accessType='inputOutput' type='MFInt32' name='type'/>
          <field accessType='inputOutput' type='SFBool' name='rotate'/>
          <field accessType='inputOutput' type='SFVec3f' name='mazeElementSize'/>
          <field accessType='initializeOnly' type='SFNode' name='inlineNode'>
            <Inline USE='_1'/>
          </field>
          <field accessType='inputOutput' type='SFNode' name='maze'/>
          <field accessType='initializeOnly' type='SFNode' name='proxy'>
            <InstancedShape USE='Proxy'/>
          </field>
          <field accessType='initializeOnly' type='SFNode' name='shape'>
            <InstancedShape USE='Shape'/>
          </field>
          <field accessType='initializeOnly' type='SFNode' name='self'>
            <Script USE='MazeGeometryScript'/>
          </field>
          <IS>
            <connect nodeField='type' protoField='type'/>
            <connect nodeField='rotate' protoField='rotate'/>
            <connect nodeField='mazeElementSize' protoField='mazeElementSize'/>
            <connect nodeField='maze' protoField='maze'/>
          </IS>
<![CDATA[ecmascript:

var route;

function initialize ()
{
	set_maze (maze, 0);
}

function set_loadTime ()
{
	const collisionNode = Browser .currentScene .getImportedNode ("MazeElement");

	shape .appearance = collisionNode .children [0] .appearance;
	shape .geometry   = collisionNode .children [0] .geometry;

	proxy .appearance = collisionNode .proxy .appearance;
	proxy .geometry   = collisionNode .proxy .geometry;
}

function set_maze (value, time)
{
	if (route)
		Browser .currentScene .deleteRoute (route);

	if (maze)
		route = Browser .currentScene .addRoute (maze, "generatedTime", self, "set_triggerTime");
}

function set_triggerTime (value, time)
{
	if (maze .matrix .length == 0)
		return;

	generateGeometry (proxy);
	generateGeometry (shape);
}

function generateGeometry (shape)
{
	const
		elementWidth = mazeElementSize .x,
		elementDepth = mazeElementSize .z,
		offset       = new SFVec3f ((maze .width - 1) * elementWidth / 2, 0, (maze .height - 1) * elementDepth / 2);

	shape .translations .length = 0;
	shape .rotations    .length = 0;

	for (let y = 0; y < maze .height; ++ y)
	{
		for (let x = 0; x < maze .width; ++ x)
		{
			if (!isType (maze .matrix [getIndex (x, y)]))
				continue;

			const translation = new SFVec3f (x * elementWidth, 0, y * elementDepth) .subtract (offset);

			if (rotate)
			{
				for (const rotation of getRotations (x, y))
				{
					shape .translations .push (translation);
					shape .rotations    .push (rotation);
				}
			}
			else
			{
				shape .translations .push (translation);
			}
		}
	}
}

function isType (value)
{
	for (var i = 0; i < type .length; ++ i)
	{
		if (type [i] == value)
			return true;
	}

	return false;
}

function getRotations (x, y)
{
	var
		rotations  = [ ],
		horizontal = false,
		vertical   = false;

	if (x > 0)                horizontal |= maze .matrix [getIndex (x - 1, y)];
	if (x < maze .width - 1)  horizontal |= maze .matrix [getIndex (x + 1, y)];
	if (y > 0)                vertical   |= maze .matrix [getIndex (x, y - 1)];
	if (y < maze .height - 1) vertical   |= maze .matrix [getIndex (x, y + 1)];

	if (! (horizontal || vertical))
	{
		horizontal = true;
		vertical   = true;
	}

	if (horizontal)
		rotations .push (new SFRotation (0, 1, 0, Math .PI / 2));

	if (vertical)
		rotations .push (new SFRotation (0, 0, 1, 0));

	return rotations;
}

function getIndex (x, y)
{
	return maze .width * y + x;
}
]]>
        </Script>
        <IMPORT inlineDEF='_1' importedDEF='MazeElement'/>
        <ROUTE fromNode='_2' fromField='loadTime' toNode='MazeGeometryScript' toField='set_loadTime'/>
        <ROUTE fromNode='Shape' fromField='translations_changed' toNode='Proxy' toField='set_translations'/>
        <ROUTE fromNode='Shape' fromField='rotations_changed' toNode='Proxy' toField='set_rotations'/>
      </ProtoBody>
    </ProtoDeclare>
    <ProtoDeclare name='Globe'>
      <ProtoInterface>
        <field accessType='inputOutput' type='SFBool' name='enabled'/>
        <field accessType='inputOnly' type='SFTime' name='set_turnTime'/>
        <field accessType='inputOutput' type='SFTime' name='cycleInterval'/>
        <field accessType='inputOutput' type='SFFloat' name='radius' value='1'/>
        <field accessType='inputOutput' type='SFVec3f' name='mazeElementSize' value='2 2 2'/>
        <field accessType='inputOutput' type='SFTime' name='startTime'/>
        <field accessType='inputOutput' type='SFTime' name='stopTime'/>
        <field accessType='outputOnly' type='SFTime' name='cycleTime'/>
        <field accessType='outputOnly' type='SFInt32' name='direction_changed'/>
        <field accessType='outputOnly' type='MFInt32' name='position_changed'/>
        <field accessType='outputOnly' type='SFVec3f' name='translation_changed'/>
        <field accessType='outputOnly' type='SFRotation' name='rotation_changed'/>
        <field accessType='inputOutput' type='SFNode' name='maze'/>
        <field accessType='inputOutput' type='MFNode' name='translationChildren'/>
        <field accessType='inputOutput' type='MFNode' name='children'/>
      </ProtoInterface>
      <ProtoBody>
        <Collision DEF='Shape'
            enabled='false'>
          <Transform DEF='_3'
              translation='-8 2 4'
              rotation='-0.284180511188001 -0.790532371841786 0.542494245251621 185.949206667814'>
            <IS>
              <connect nodeField='translation' protoField='translation_changed'/>
              <connect nodeField='rotation' protoField='rotation_changed'/>
              <connect nodeField='children' protoField='children'/>
            </IS>
          </Transform>
          <Group>
            <IS>
              <connect nodeField='children' protoField='translationChildren'/>
            </IS>
          </Group>
        </Collision>
        <Script DEF='GlobeScript'
            directOutput='true'>
          <field accessType='inputOutput' type='SFTime' name='cycleInterval'/>
          <field accessType='inputOnly' type='SFTime' name='set_triggerTime'/>
          <field accessType='inputOnly' type='SFTime' name='set_turnTime'/>
          <field accessType='inputOnly' type='SFTime' name='set_cycleTime'/>
          <field accessType='inputOutput' type='SFFloat' name='radius'/>
          <field accessType='inputOutput' type='SFVec3f' name='mazeElementSize'/>
          <field accessType='outputOnly' type='SFInt32' name='direction_changed'/>
          <field accessType='outputOnly' type='MFInt32' name='position_changed'/>
          <field accessType='inputOutput' type='SFNode' name='maze'/>
          <field accessType='initializeOnly' type='SFNode' name='transform'>
            <Transform USE='_3'/>
          </field>
          <field accessType='initializeOnly' type='SFNode' name='timeSensor'>
            <TimeSensor DEF='_4'
                cycleInterval='0'
                loop='true'>
              <IS>
                <connect nodeField='enabled' protoField='enabled'/>
                <connect nodeField='startTime' protoField='startTime'/>
                <connect nodeField='stopTime' protoField='stopTime'/>
                <connect nodeField='cycleTime' protoField='cycleTime'/>
              </IS>
            </TimeSensor>
          </field>
          <field accessType='initializeOnly' type='SFNode' name='positionInterpolator'>
            <PositionInterpolator DEF='_5'
                key='0, 1'
                keyValue='-8 2 4, -4 2 4'/>
          </field>
          <field accessType='initializeOnly' type='SFNode' name='orientationInterpolator'>
            <OrientationInterpolator DEF='_6'
                key='0, 0.25, 0.5, 0.75, 1'
                keyValue='-0.284180511188001 -0.790532371841786 0.542494245251621 185.949206667814, 0.471950584965486 0.697161480359967 -0.539655923392892 189.608794592081, 0.64245736891161 0.569991777568564 -0.512208846697712 204.736550266607, 0.790426756107843 0.407195559520415 -0.457621371371233 218.697477248719, 0.904626025961796 0.207714310453148 -0.372164638816668 230.661122157893'/>
          </field>
          <field accessType='initializeOnly' type='SFNode' name='self'>
            <Script USE='GlobeScript'/>
          </field>
          <IS>
            <connect nodeField='cycleInterval' protoField='cycleInterval'/>
            <connect nodeField='set_turnTime' protoField='set_turnTime'/>
            <connect nodeField='radius' protoField='radius'/>
            <connect nodeField='mazeElementSize' protoField='mazeElementSize'/>
            <connect nodeField='direction_changed' protoField='direction_changed'/>
            <connect nodeField='position_changed' protoField='position_changed'/>
            <connect nodeField='maze' protoField='maze'/>
          </IS>
<![CDATA[ecmascript:

var
	ANY   = -1,
	WEST  = 0,
	EAST  = 1,
	SOUTH = 2,
	NORTH = 3;

var route;

var opposites = [	1, 0, 3, 2 ];

var
	turnTime     = 0,
	turnInterval = 0;

function initialize ()
{
	set_maze (maze, 0);
}

function set_maze (value, time)
{
	if (route)
		Browser .currentScene .deleteRoute (route);

	if (maze)
	{
		route = Browser .currentScene .addRoute (maze, "generatedTime", self, "set_triggerTime");

		set_triggerTime (time, time);
	}
}

function set_triggerTime (value, time)
{
	if (maze .matrix .length == 0)
		return;

	var x, y;

	do
	{
		x = Math .floor (Math .random () * maze .width);
		y = Math .floor (Math .random () * maze .height);
	}
	while (maze .matrix [getIndex (x, y)] != 0);

	direction_changed        = ANY;
	position_changed [0]     = x;
	position_changed [1]     = y;
	position_changed [2]     = x;
	position_changed [3]     = y;

	transform .translation = getTranslation (x ,y);
	transform .rotation    = new SFRotation ();

	timeSensor .cycleInterval         = cycleInterval;
	positionInterpolator    .key      = new MFFloat (0, 1);
	orientationInterpolator .key      = new MFFloat (0, 1);
	positionInterpolator    .keyValue = new MFVec3f (transform .translation, transform .translation);
	orientationInterpolator .keyValue = new MFRotation (transform .rotation, transform .rotation);
}

function set_turnTime (value, time)
{
	if (! maze)
		return;

	if (maze .matrix .length == 0)
		return;

	if (time - turnTime < turnInterval)
		return;

	turnTime = time;

	var
		x  = position_changed [0],
		y  = position_changed [1],
		fc = timeSensor .fraction_changed * cycleInterval;

	direction_changed = opposites [direction_changed];

	position_changed [0] = position_changed [2];
	position_changed [1] = position_changed [3];
	position_changed [2] = x;
	position_changed [3] = y;

	if (timeSensor .fraction_changed >= 1)
		timeSensor .cycleInterval = cycleInterval;
	else
		timeSensor .cycleInterval = fc / (cycleInterval - fc) * cycleInterval;

	mirrorInterpolator (timeSensor .fraction_changed, positionInterpolator);
	mirrorInterpolator (timeSensor .fraction_changed, orientationInterpolator);

	turnInterval = timeSensor .cycleInterval * (1 - timeSensor .fraction_changed);
}

function mirrorInterpolator (f, interpolator)
{
	for (var i = 0; i < interpolator .key .length; ++ i)
	{
		if (interpolator .key [i] >= f)
			break;
	}

	var k = i + 1;

	interpolator .key [i]      = f;
	interpolator .keyValue [i] = interpolator .value_changed;

	if (i)
	{
		for (-- i; i >= 0; -- i, ++ k)
		{
			interpolator .key [k]      = f + (1 - interpolator .key [i] / f) * (1 - f);
			interpolator .keyValue [k] = interpolator .keyValue [i];
		}
	}

	interpolator .key      .length = k;
	interpolator .keyValue .length = k;
}

function set_cycleTime (value, time)
{
	if (! maze)
		return;

	if (maze .matrix .length == 0)
		return;

	// Determine new position.

	var positions = getPositions (position_changed [2], position_changed [3], direction_changed);

	if (positions .length == 0)
		positions = getPositions (position_changed [2], position_changed [3], ANY);

	var index = Math .floor (Math .random () * positions .length);

	direction_changed = positions [index] [2];

	position_changed [0] = position_changed [2];
	position_changed [1] = position_changed [3];
	position_changed [2] = positions [index] [0];
	position_changed [3] = positions [index] [1];

	// Setup interpolators.

	var
		startTranslation = positionInterpolator .value_changed,
		stopTranslation  = getTranslation (position_changed [2], position_changed [3]),
		startRotation    = orientationInterpolator .value_changed,
		rotations        = getRotations (startTranslation, stopTranslation);

	timeSensor .cycleInterval = cycleInterval;

	positionInterpolator .key [0]     = 0;
	positionInterpolator .key [1]     = 1;
	positionInterpolator .key .length = 2;

	positionInterpolator .keyValue [0]     = startTranslation;
	positionInterpolator .keyValue [1]     = stopTranslation;
	positionInterpolator .keyValue .length = 2;

	for (var i = 0; i < rotations .length; ++ i)
	{
		orientationInterpolator .key [i]      = i / (rotations .length - 1);
		orientationInterpolator .keyValue [i] = startRotation .multiply (rotations [i]);
	}

	orientationInterpolator .key      .length = rotations .length;
	orientationInterpolator .keyValue .length = rotations .length;
}

function getTranslation (x ,y)
{
	var offset = new SFVec3f ((maze .width - 1) * mazeElementSize .x / 2,
	                          0,
	                          (maze .height - 1) * mazeElementSize .z / 2);

	var translation = new SFVec3f (x * mazeElementSize .x, radius, y * mazeElementSize .z);

	return translation .subtract (offset);
}

function getRotations (startTranslation, stopTranslation)
{
	var
		rotations   = new MFRotation (),
		direction   = stopTranslation .subtract (startTranslation),
		axis        = direction .cross (new SFVec3f (0, 1, 0)),
		length      = direction .length (),
		revolutions = length / (2 * Math .PI * radius),
		numKeys     = Math .ceil (revolutions) * 4;

	for (var i = 0; i <= numKeys; ++ i)
		rotations .push (new SFRotation (axis, -i / numKeys * revolutions * 2 * Math .PI));

	return rotations;
}

function getPositions (x, y, direction)
{
	var positions = [ ];

	if (direction != EAST)
		if (x > 0)
			if (maze .matrix [getIndex (x - 1, y)] == 0)
				positions .push ([x - 1, y, WEST]);

	if (direction != WEST)
		if (x < maze .width - 1)
			if (maze .matrix [getIndex (x + 1, y)] == 0)
				positions .push ([x + 1, y, EAST]);

	if (direction != NORTH)
		if (y > 0)
			if (maze .matrix [getIndex (x, y - 1)] == 0)
				positions .push ([x, y - 1, SOUTH]);

	if (direction != SOUTH)
		if (y < maze .height - 1)
			if (maze .matrix [getIndex (x, y + 1)] == 0)
				positions .push ([x, y + 1, NORTH]);

	return positions;
}

function getIndex (x, y)
{
	return maze .width * y + x;
}
]]>
        </Script>
        <ROUTE fromNode='_4' fromField='fraction_changed' toNode='_6' toField='set_fraction'/>
        <ROUTE fromNode='_4' fromField='fraction_changed' toNode='_5' toField='set_fraction'/>
        <ROUTE fromNode='_4' fromField='cycleTime' toNode='GlobeScript' toField='set_cycleTime'/>
        <ROUTE fromNode='_6' fromField='value_changed' toNode='_3' toField='set_rotation'/>
        <ROUTE fromNode='_5' fromField='value_changed' toNode='_3' toField='set_translation'/>
      </ProtoBody>
    </ProtoDeclare>
    <ProtoDeclare name='MazeCollisionManager'>
      <ProtoInterface>
        <field accessType='inputOutput' type='MFNode' name='collidables'/>
      </ProtoInterface>
      <ProtoBody>
        <Script DEF='MazeCollisionManagerScript'
            directOutput='true'>
          <field accessType='inputOnly' type='MFInt32' name='set_position'/>
          <field accessType='inputOnly' type='SFVec3f' name='set_translation'/>
          <field accessType='inputOutput' type='MFNode' name='collidables'/>
          <field accessType='initializeOnly' type='SFNode' name='self'>
            <Script USE='MazeCollisionManagerScript'/>
          </field>
          <IS>
            <connect nodeField='collidables' protoField='collidables'/>
          </IS>
<![CDATA[ecmascript:

var
	routes      = [ ],
	connections = [ ],
	map         = { };

function initialize ()
{
	set_collidables (collidables, 0);
}

function set_position (value, time)
{
	var currentScene = Browser .currentScene;

	for (var i = 0; i < connections .length; ++ i)
	{
		currentScene .deleteRoute (connections [i]);
	}

	map = { };

	for (var i = 0; i < collidables .length; ++ i)
	{
		var
			collidable = collidables [i],
			position   = collidable .position_changed;

		for (var p = 0; p < position .length; p += 2)
		{
			var
				x = position [p + 0],
				y = position [p + 1],
				k = x + ":" + y,
				m = map [k];

			if (! m)
				m = map [k] = [ ];

			m .push (collidable);
		}
	}

	for (var k in map)
	{
		var m = map [k];

		if (m .length < 2)
		{
			delete map [k];
			continue;
		}

		connections .push (currentScene .addRoute (m [0], "translation_changed", self, "set_translation"));
	}
}

function set_translation (value, time)
{
	for (var k in map)
	{
		var m = map [k];

		for (var c1 = 0; c1 < m .length; ++ c1)
		{
			var collidable1 = m [c1];

			for (var c2 = 0; c2 < m .length; ++ c2)
			{
				var collidable2 = m [c2];

				if (collidable1 === collidable2)
					continue;

				var
					r = collidable1 .radius + collidable2 .radius,
					l = collidable1 .translation_changed .subtract (collidable2 .translation_changed) .length ();

				if (l < r)
				{
					if (collidable1 .direction_changed == collidable2 .direction_changed)
					{
						if (collidable1 .cycleInterval < collidable2 .cycleInterval)
							collidable1 .set_turnTime = time;
					}
					else
					{
						collidable1 .set_turnTime = time;
					}
				}
			}
		}
	}
}

function set_collidables (value, time)
{
	var currentScene = Browser .currentScene;

	for (var i = 0; i < routes .length; ++ i)
	{
		currentScene .deleteRoute (routes [i]);
	}

	routes .length = 0;

	for (var i = 0; i < collidables .length; ++ i)
	{
		routes .push (currentScene .addRoute (collidables [i], "position_changed", self, "set_position"));
	}
}

function eventsProcessed ()
{

}
]]>
        </Script>
      </ProtoBody>
    </ProtoDeclare>
    <ProtoDeclare name='BonusMap'>
      <ProtoInterface>
        <field accessType='inputOutput' type='MFFloat' name='density' value='1'/>
        <field accessType='inputOutput' type='SFVec3f' name='mazeElementSize'/>
        <field accessType='outputOnly' type='SFInt32' name='item_changed'/>
        <field accessType='outputOnly' type='SFTime' name='enterTime'/>
        <field accessType='inputOutput' type='SFNode' name='maze'/>
        <field accessType='inputOutput' type='MFNode' name='items'/>
      </ProtoInterface>
      <ProtoBody>
        <Collision DEF='Group_7'
            enabled='false'/>
        <Script DEF='BonusMapScript'
            directOutput='true'>
          <field accessType='inputOnly' type='SFTime' name='set_triggerTime'/>
          <field accessType='inputOnly' type='SFTime' name='set_enterTime'/>
          <field accessType='inputOutput' type='MFFloat' name='density'/>
          <field accessType='inputOutput' type='SFVec3f' name='mazeElementSize'/>
          <field accessType='outputOnly' type='SFInt32' name='item_changed'/>
          <field accessType='outputOnly' type='SFTime' name='enterTime'/>
          <field accessType='inputOutput' type='SFNode' name='maze'/>
          <field accessType='inputOutput' type='MFNode' name='items'/>
          <field accessType='initializeOnly' type='SFNode' name='group'>
            <Collision USE='Group_7'/>
          </field>
          <field accessType='initializeOnly' type='SFNode' name='self'>
            <Script USE='BonusMapScript'/>
          </field>
          <IS>
            <connect nodeField='density' protoField='density'/>
            <connect nodeField='mazeElementSize' protoField='mazeElementSize'/>
            <connect nodeField='item_changed' protoField='item_changed'/>
            <connect nodeField='enterTime' protoField='enterTime'/>
            <connect nodeField='maze' protoField='maze'/>
            <connect nodeField='items' protoField='items'/>
          </IS>
<![CDATA[ecmascript:

var route;

function initialize ()
{
	set_maze (maze, 0);
}

function set_triggerTime (value, time)
{
	if (! maze)
		return;

	group .children .length = 0;

	for (var y = 0; y < maze .height; ++ y)
	{
		for (var x = 0; x < maze .width; ++ x)
		{
			if (maze .matrix [getIndex (x, y)])
				continue;

			for (var d = 0; d < density .length; ++ d)
			{
				if (Math .random () < density [d])
					break;
			}

			if (d >= items .length)
				continue;

			group .children .push (getNode (d, x, y));
		}
	}
}

function set_enterTime (value, time)
{
	enterTime = time;

	for (var i = 0; i < group .children .length; ++ i)
	{
		var
			transform       = group .children [i],
			lod             = transform .children [0],
			visiblitySensor = lod .children [0];

		if (visiblitySensor .enterTime == value)
		{
			group .removeChildren = new MFNode (transform);
			break;
		}
	}
}

function set_maze (value, time)
{
	if (route)
		Browser .currentScene .deleteRoute (route);

	if (maze)
		route = Browser .currentScene .addRoute (maze, "generatedTime", self, "set_triggerTime");
}

function getNode (b, x, y)
{
	var
		currentScene    = Browser .currentScene,
		lod             = currentScene .createNode ("LOD"),
		transform       = currentScene .createNode ("Transform"),
		visiblitySensor = currentScene .createNode ("VisibilitySensor");

	Browser .currentScene .addRoute (visiblitySensor, "enterTime", self, "set_enterTime");

	lod .range .push (1);
	lod .children .push (visiblitySensor);
	lod .children .push (items [b]);

	visiblitySensor .size  = new SFVec3f (1, 1, 1);
	transform .translation = getTranslation (x, y);
	transform .children .push (lod);

	return transform;
}

function getTranslation (x ,y)
{
	var offset = new SFVec3f ((maze .width - 1) * mazeElementSize .x / 2,
	                          0,
	                          (maze .height - 1) * mazeElementSize .z / 2);

	var translation = new SFVec3f (x * mazeElementSize .x, 1.2, y * mazeElementSize .z);

	return translation .subtract (offset);
}

function getIndex (x, y)
{
	return maze .width * y + x;
}

]]>
        </Script>
      </ProtoBody>
    </ProtoDeclare>
    <ProtoDeclare name='TimeControler'>
      <ProtoInterface>
        <field accessType='inputOutput' type='SFTime' name='resetTime'/>
        <field accessType='inputOutput' type='SFNode' name='timer'/>
      </ProtoInterface>
      <ProtoBody>
        <Script DEF='TimeControlerScript'
            directOutput='true'>
          <field accessType='inputOutput' type='SFTime' name='resetTime'/>
          <field accessType='inputOutput' type='SFNode' name='timer'/>
          <IS>
            <connect nodeField='resetTime' protoField='resetTime'/>
            <connect nodeField='timer' protoField='timer'/>
          </IS>
<![CDATA[ecmascript:

function set_resetTime (value, time)
{
	if (! timer)
		return;

	timer .stopTime  = value;
	timer .startTime = value;
}
]]>
        </Script>
      </ProtoBody>
    </ProtoDeclare>
    <WorldInfo/>
    <LayerSet DEF='_25'
        activeLayer='1'
        order='2, 3'>
      <Layer DEF='Playground'
          pickable='false'>
        <TimeTrigger DEF='_57'/>
        <ProtoInstance name='MFInt32' DEF='_58'>
          <fieldValue name='keyValue' value='1, 3'/>
        </ProtoInstance>
        <NavigationInfo DEF='None'
            type='"NONE"'
            transitionType='"TELEPORT"'/>
        <OrthoViewpoint
            position='0 50.1169 0'
            orientation='1 0 0 270'
            fieldOfView='-36, -20, 36, 20'/>
        <Background DEF='_59'
            skyAngle='76.5191, 90.0002'
            skyColor='0.045 0.045 0.045, 0.195 0.195 0.195, 0.185 0.185 0.185'
            groundAngle='60.5651, 90.0002'
            groundColor='0 0 0, 0 0 0, 0.185 0.185 0.185'/>
        <DirectionalLight
            intensity='0.656934'
            ambientIntensity='0.382716'
            direction='0.65147 2.93442e-8 -0.758675'/>
        <DirectionalLight
            ambientIntensity='0.302469'
            direction='-3.52397e-6 -0.860529 0.509401'
            shadows='true'/>
        <Group DEF='Navigation'>
          <NavigationInfo DEF='Walk'
              type='"WALK"'
              headlight='false'
              transitionType='"TELEPORT"'/>
          <Viewpoint DEF='_62'
              description='Maze'
              position='28 2 12'
              orientation='0 1 0 90'
              centerOfRotation='2.30881 1.59995 -0.422763'/>
          <Script DEF='ViewpointPositionScript'
              directOutput='true'>
            <field accessType='inputOnly' type='SFTime' name='set_triggerTime'/>
            <field accessType='inputOutput' type='SFVec3f' name='mazeElementSize' value='4 2 4'/>
            <field accessType='outputOnly' type='SFVec3f' name='position_changed'/>
            <field accessType='outputOnly' type='SFRotation' name='orientation_changed'/>
            <field accessType='initializeOnly' type='SFNode' name='maze'>
              <ProtoInstance name='Maze' DEF='_63'>
                <fieldValue name='width' value='17'/>
                <fieldValue name='height' value='17'/>
              </ProtoInstance>
            </field>
<![CDATA[ecmascript:

function set_triggerTime (value, time)
{
	if (maze .matrix .length == 0)
		return;

	var
		x = -1,
		y = -1;

	do
	{
		x = Math .floor (Math .random () * maze .width);
		y = Math .floor (Math .random () * maze .height);
	}
	while (maze .matrix [getIndex (x, y)] != 0);

	var offset = new SFVec3f ((maze .width - 1) * mazeElementSize .x / 2, 0, (maze .height - 1) * mazeElementSize .z / 2);



	var position = new SFVec3f (x * mazeElementSize .x, mazeElementSize .y, y * mazeElementSize .z);
	position = position .subtract (offset);

	bind                = true;
	position_changed    = position;
	orientation_changed = getRotation (x, y);
}

function getRotation (x, y)
{
	if (x > 0)
		if (maze .matrix [getIndex (x - 1, y)] == 0)
			return new SFRotation (0, 1, 0, 1 / 2 * Math .PI);

	if (x < maze .width - 1)
		if (maze .matrix [getIndex (x + 1, y)] == 0)
			return new SFRotation (0, 1, 0, 3 / 2 * Math .PI);

	if (y > 0)
		if (maze .matrix [getIndex (x, y - 1)] == 0)
			return new SFRotation (0, 1, 0, Math .PI);

	if (y < maze .height - 1)
		if (maze .matrix [getIndex (x, y + 1)] == 0)
			return new SFRotation (0, 1, 0, 0);

	return new SFRotation (0, 1, 0, 0);
}

function getIndex (x, y)
{
	return maze .width * y + x;
}
]]>
          </Script>
        </Group>
        <ProtoInstance name='MazeGeometry' DEF='Walls'>
          <fieldValue name='mazeElementSize' value='4 2 4'/>
          <fieldValue name='mazeElementUrl' value='"maze-element.x3d"'/>
          <fieldValue name='maze'>
            <ProtoInstance name='Maze' USE='_63'/>
          </fieldValue>
        </ProtoInstance>
        <ProtoInstance name='MazeGeometry' DEF='Floor'>
          <fieldValue name='type' value='0, 1'/>
          <fieldValue name='rotate' value='false'/>
          <fieldValue name='mazeElementSize' value='4 2 4'/>
          <fieldValue name='mazeElementUrl' value='"maze-floor-element.x3d"'/>
          <fieldValue name='maze'>
            <ProtoInstance name='Maze' USE='_63'/>
          </fieldValue>
        </ProtoInstance>
        <LoadSensor>
          <ProtoInstance name='MazeGeometry' USE='Walls'/>
          <ProtoInstance name='MazeGeometry' USE='Floor'/>
          <Inline DEF='Globe1'
              global='true'
              url='"globe1.x3d"'/>
        </LoadSensor>
        <Group DEF='Globes'
            bboxSize='70 10 70'
            bboxCenter='0 2 0'>
          <ProtoInstance name='MazeCollisionManager'>
            <fieldValue name='collidables'>
              <ProtoInstance name='Globe' DEF='_64'>
                <fieldValue name='cycleInterval' value='4'/>
                <fieldValue name='radius' value='2'/>
                <fieldValue name='mazeElementSize' value='4 2 4'/>
                <fieldValue name='startTime' value='1508046433.07247'/>
                <fieldValue name='stopTime' value='1508046433.07247'/>
                <fieldValue name='maze'>
                  <ProtoInstance name='Maze' USE='_63'/>
                </fieldValue>
                <fieldValue name='children'>
                  <Inline USE='Globe1'/>
                </fieldValue>
              </ProtoInstance>
              <ProtoInstance name='Globe' DEF='_65'>
                <fieldValue name='cycleInterval' value='4'/>
                <fieldValue name='radius' value='2'/>
                <fieldValue name='mazeElementSize' value='4 2 4'/>
                <fieldValue name='startTime' value='1507984705.53519'/>
                <fieldValue name='stopTime' value='1507984705.53519'/>
                <fieldValue name='maze'>
                  <ProtoInstance name='Maze' USE='_63'/>
                </fieldValue>
                <fieldValue name='children'>
                  <Inline USE='Globe1'/>
                </fieldValue>
              </ProtoInstance>
            </fieldValue>
          </ProtoInstance>
          <ProtoInstance name='Globe' USE='_64'/>
          <ProtoInstance name='Globe' USE='_65'/>
        </Group>
        <ProtoInstance name='BonusMap' DEF='_66'>
          <fieldValue name='density' value='0.8'/>
          <fieldValue name='mazeElementSize' value='4 2 4'/>
          <fieldValue name='maze'>
            <ProtoInstance name='Maze' USE='_63'/>
          </fieldValue>
          <fieldValue name='items'>
            <Inline DEF='_67'
                global='true'
                url='"bonus-mint.x3d"'/>
            <Inline DEF='_68'
                global='true'
                url='"bonus-blue.x3d"'/>
          </fieldValue>
        </ProtoInstance>
        <Group DEF='BonusSound_69'>
          <Sound DEF='BonusSound'
              intensity='0.133159'
              minBack='55'
              minFront='55'
              maxBack='60'
              maxFront='60'>
            <AudioClip DEF='_70'
                url='"star-collect.mp3"'
                startTime='1759010544.236'
                pauseTime='1510042948.99191'
                stopTime='1759010544.236'/>
          </Sound>
          <ProtoInstance name='TimeControler' DEF='_71'>
            <fieldValue name='resetTime' value='1759010544.236'/>
            <fieldValue name='timer'>
              <AudioClip USE='_70'/>
            </fieldValue>
          </ProtoInstance>
        </Group>
        <VisibilitySensor DEF='_72'
            size='-1 -1 -1'/>
      </Layer>
      <Layer DEF='HUD'>
        <TimeTrigger DEF='_86'/>
        <ProtoInstance name='MFInt32' DEF='_87'>
          <fieldValue name='keyValue' value='2, 3'/>
        </ProtoInstance>
        <Transform DEF='Background'
            translation='0 0 -10'
            scale='35.7089 35.7089 35.7089'>
          <Shape>
            <Appearance>
              <ImageTexture
                  url='"hud-background.jpg"'
                  repeatS='false'
                  repeatT='false'/>
            </Appearance>
            <Rectangle2D
                size='1.05833 0.705556'/>
          </Shape>
        </Transform>
        <Transform DEF='SugarSmack'
            translation='-5.04174 1.24997 0'>
          <Shape>
            <Appearance>
              <Material DEF='Rococo28'
                  ambientIntensity='0.226102'
                  diffuseColor='0 0 0'
                  specularColor='0.0955906 0.0955906 0.0955906'
                  shininess='0.078125'/>
            </Appearance>
            <Text
                string='"Sugar Smack"'
                solid='true'>
              <FontStyle
                  family='"Minimum-Toc.otf"'
                  size='0.6'
                  justify='"BEGIN", "BEGIN"'/>
            </Text>
          </Shape>
        </Transform>
        <Transform DEF='StartNewGame'>
          <Transform DEF='Rectangle2D'
              translation='-0.568659 -0.0935914 0'
              scale='4.65256 0.593919 1'>
            <Shape>
              <Appearance>
                <Material
                    transparency='1'/>
              </Appearance>
              <Rectangle2D/>
            </Shape>
          </Transform>
          <Transform DEF='Text'
              translation='-5.04174 0.329928 0'
              scale='2.3206 2.3206 2.3206'>
            <Shape>
              <Appearance>
                <Material DEF='Rococo13'
                    ambientIntensity='0.187004'
                    diffuseColor='0.840849 0.227154 0.32302'
                    specularColor='0.251984 0.251984 0.251984'
                    shininess='0.6'/>
              </Appearance>
              <Text
                  string='"Start New Game"'
                  solid='true'>
                <FontStyle
                    family='"Minimum-Toc.otf"'
                    size='0.6'
                    justify='"BEGIN", "BEGIN"'/>
              </Text>
            </Shape>
          </Transform>
          <TouchSensor DEF='_88'/>
        </Transform>
      </Layer>
      <Layer DEF='Debug'>
        <Switch>
          <Transform DEF='Reset'
              translation='6.74236 -3.02708 0'
              scale='0.473103 0.473103 0.473103'>
            <Shape>
              <Appearance>
                <Material/>
              </Appearance>
              <Box/>
            </Shape>
            <BooleanTrigger DEF='_89'/>
            <BooleanToggle DEF='_90'/>
            <BooleanFilter DEF='_91'/>
            <TouchSensor USE='_88'/>
          </Transform>
        </Switch>
      </Layer>
    </LayerSet>
    <Script DEF='EnterWorldScript'>
      <field accessType='outputOnly' type='SFBool' name='entered'/>
<![CDATA[ecmascript:

function initialize ()
{
	Browser .setBrowserOption ("Shading", "PHONG");

	entered = true;
}
]]>
    </Script>
    <BooleanFilter DEF='_92'/>
    <ROUTE fromNode='ViewpointPositionScript' fromField='position_changed' toNode='_62' toField='set_position'/>
    <ROUTE fromNode='ViewpointPositionScript' fromField='orientation_changed' toNode='_62' toField='set_orientation'/>
    <ROUTE fromNode='_90' fromField='toggle_changed' toNode='_91' toField='set_boolean'/>
    <ROUTE fromNode='_88' fromField='touchTime' toNode='_89' toField='set_triggerTime'/>
    <ROUTE fromNode='_89' fromField='triggerTrue' toNode='_90' toField='set_boolean'/>
    <ROUTE fromNode='_72' fromField='isActive' toNode='_59' toField='set_bind'/>
    <ROUTE fromNode='_63' fromField='generatedTime' toNode='ViewpointPositionScript' toField='set_triggerTime'/>
    <ROUTE fromNode='_72' fromField='isActive' toNode='_62' toField='set_bind'/>
    <ROUTE fromNode='EnterWorldScript' fromField='entered' toNode='_92' toField='set_boolean'/>
    <ROUTE fromNode='_92' fromField='inputNegate' toNode='_90' toField='set_toggle'/>
    <ROUTE fromNode='_72' fromField='isActive' toNode='Walk' toField='set_bind'/>
    <ROUTE fromNode='_91' fromField='inputTrue' toNode='_57' toField='set_boolean'/>
    <ROUTE fromNode='_91' fromField='inputFalse' toNode='_86' toField='set_boolean'/>
    <ROUTE fromNode='_57' fromField='triggerTime' toNode='_63' toField='set_triggerTime'/>
    <ROUTE fromNode='_72' fromField='isActive' toNode='_64' toField='set_enabled'/>
    <ROUTE fromNode='_72' fromField='isActive' toNode='_65' toField='set_enabled'/>
    <ROUTE fromNode='_66' fromField='enterTime' toNode='_71' toField='set_resetTime'/>
    <ROUTE fromNode='_87' fromField='value_changed' toNode='_25' toField='set_order'/>
    <ROUTE fromNode='_86' fromField='triggerTime' toNode='_87' toField='set_triggerTime'/>
    <ROUTE fromNode='_58' fromField='value_changed' toNode='_25' toField='set_order'/>
    <ROUTE fromNode='_57' fromField='triggerTime' toNode='_58' toField='set_triggerTime'/>
  </Scene>
</X3D>
